'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.start = start;

require('babel-polyfill');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _actions = require('./pageActions/actions');

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _marked = [start].map(regeneratorRuntime.mark);

var phantom = require('phantom');

function futurePages(ph, links) {
  return _lodash2.default.map(links, function (link, key) {
    return ph.createPage().then(function (page) {
      return { page: page, key: key, link: link };
    });
  });
};

function getElements(page) {
  return function (elements) {
    return _lodash2.default.reduce(elements, function (pre, _ref, keyElement) {
      var fn = _ref.fn;
      var css = _ref.css;
      var shaper = _ref.shaper;

      console.log('getting element: ' + keyElement + ' with css ' + css + ' and this fn: ' + fn);
      var getElement = null;
      try {
        getElement = actions[fn](page, css);
      } catch (ex) {
        getElement = Promise.resolve('Error while resolving this: ' + fn);
      }
      pre[keyElement] = getElement.then(shaper);
      return pre;
    }, {});
  };
}

function promiseMapObject(obj) {
  var keys = Object.keys(obj);
  var promises = keys.map(function (key) {
    return obj[key];
  });

  return Promise.all(promises).then(_lodash2.default.partial(_lodash2.default.zipObject, keys));
}

function addTimeStamp(obj) {
  obj.timestamp = Date.now();
  return obj;
}

function scrapElements(pages, elements) {
  var promiseOfObject = _lodash2.default.reduce(pages, function (pre, _ref2) {
    var page = _ref2.page;
    var key = _ref2.key;
    var link = _ref2.link;

    pre[key] = page.open(link).then(function (success) {
      return success === 'success' ? elements : Promise.reject('Not possible to open link: ' + link);
    }).then(getElements(page)).then(promiseMapObject).then(addTimeStamp).catch(function (err) {
      return 'error: ' + err;
    });
    return pre;
  }, {});

  return promiseMapObject(promiseOfObject);
}

function start(_ref3) {
  var links = _ref3.links;
  var elements = _ref3.elements;
  var ph, pages, result;
  return regeneratorRuntime.wrap(function start$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          console.log('Starting a new Phantom process');
          _context.next = 3;
          return phantom.create();

        case 3:
          ph = _context.sent;
          _context.next = 6;
          return futurePages(ph, links);

        case 6:
          pages = _context.sent;
          _context.next = 9;
          return scrapElements(pages, elements);

        case 9:
          result = _context.sent;

          console.log('Exit the Phantom process');
          ph.exit();
          return _context.abrupt('return', result);

        case 13:
        case 'end':
          return _context.stop();
      }
    }
  }, _marked[0], this);
}